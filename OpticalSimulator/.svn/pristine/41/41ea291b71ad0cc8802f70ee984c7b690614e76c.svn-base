package br.upe.heuristics.bruteForce;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.PrintWriter;
import java.util.ArrayList;

import br.upe.base.Amplifier;
import br.upe.base.AmplifierType;
import br.upe.base.ObjectiveFunction;
import br.upe.initializations.UniformInitialization;
import br.upe.metrics.BeckerNoiseFigureMetric;
import br.upe.metrics.SimpleFlatnessMetric;
import br.upe.metrics.SumPowerConsumption;
import br.upe.objfunctions.rn.NNFunction;
import br.upe.simulations.simsetups.CPqDTestBed;
import br.upe.simulations.simsetups.SimulationSetup;
import br.upe.util.Dominance;

public class BruteForceMethodRestricted_8Amp {

	private float INPUT_POWER = 0.0f; // dBm
	private static final int NUMBER_OBJ = 3;
	private static float STEP = 1.0f; //dB

	private static float MAX_GAIN = 24;
	private static float MIN_GAIN = 12;

	private UniformInitialization initialization;
	private SimpleFlatnessMetric gfCalculation;
	private BeckerNoiseFigureMetric nfCalculation;
	private SumPowerConsumption sumPoutCalculation;
	private ObjectiveFunction function;
	private File arquivo;
	private SimulationSetup simSet;

	private ArrayList<SolutionBFMethod> externalArchive;

	public BruteForceMethodRestricted_8Amp(){
		function = new NNFunction();

		simSet = new CPqDTestBed();

		initialization = new UniformInitialization(AmplifierType.L17_40CH);
		gfCalculation = new SimpleFlatnessMetric();
		nfCalculation = new BeckerNoiseFigureMetric(simSet.getLINK_LOSSES());
		sumPoutCalculation = new SumPowerConsumption(80, 10);

		INPUT_POWER = 0.0f; //DecibelConverter.calculateInputPower(simSet.getCHANNELS(), simSet.getCHANNEL_POWER());

		try{
			arquivo = new File(STEP + "dB_" + simSet.getCHANNELS() + "ch_");
		}
		catch(Exception e){

		}

	}

	public void run(){

		long ti = System.currentTimeMillis();
		// System.out.println("Start");

		double totalComb = (10.0/STEP)+1;
		totalComb = totalComb * totalComb * totalComb * totalComb; 

		double contador = 0;
		SolutionBFMethod bestSol = null;
		double bestDi = Double.MAX_VALUE;
		

		float i = 20;

		while(i>=MIN_GAIN){	//G1

			float j = MAX_GAIN;
			while(j>=MIN_GAIN){	//G2

				float k = MAX_GAIN;
				while(k>=MIN_GAIN){	//G3

					float l = MAX_GAIN;
					while(l>=MIN_GAIN){	//G4

						float m = MAX_GAIN;
						while (m >= MIN_GAIN) { // G5

							float n = MAX_GAIN;
							while (n >= MIN_GAIN) { // G6

								float o = MAX_GAIN;
								while (o >= MIN_GAIN) { // G7

									float p = MAX_GAIN;
									while (p >= MIN_GAIN) { // G8

										float[] gains = { i, j, k, l, m, n, o, p };

										initialization.setGains(gains);
										Amplifier[] amplifiers = initialization.initialize(
												simSet.getNumberOfAmplifiers(),
												INPUT_POWER, 0, simSet.getLINK_LOSSES(),
												function);

										// Solucao fora das restricoes
										if (amplifiers == null
												|| Math.abs(amplifiers[0].getInputPower()) > (Math
														.abs(INPUT_POWER) + 0.2)
														|| Math.abs(amplifiers[0].getInputPower()) < (Math
																.abs(INPUT_POWER) - 0.2)) {
											p -= STEP;
											contador++;
											continue;
										}

										SolutionBFMethod solution = null;

										// If the output power of the link is less than the
										// input power, then the solution isn't desirable.
										// And, if the output power is greater than the
										// input power + voa max attenuation, then the
										// solution is not desirable
										if (amplifiers[amplifiers.length - 1]
												.getOutputPower() >= INPUT_POWER
												&& amplifiers[amplifiers.length - 1]
														.getOutputPower() <= (INPUT_POWER + simSet
																.getVOA_MAX_ATT() + simSet.getROADM_ATT())) {

											solution = new SolutionBFMethod(NUMBER_OBJ);

											solution.setAmplifiers(amplifiers);

											// Adding the VOA attenuation to the noise
											// figure
											// calculation
											if (nfCalculation instanceof BeckerNoiseFigureMetric) {
												float voaAttenuation = (float) (amplifiers[amplifiers.length - 1]
														.getOutputPower() - INPUT_POWER - simSet.getROADM_ATT());
												((BeckerNoiseFigureMetric) nfCalculation)
												.setVoaAttenuation(voaAttenuation);
											}

											solution.setFitness(0,
													nfCalculation.evaluate(amplifiers)); // nf
											solution.setFitness(1,
													gfCalculation.evaluate(amplifiers)); // gf
											solution.setFitness(2,
													sumPoutCalculation.evaluate(amplifiers)); // sumPout
											
											//Choose best solution
											double[] fitness = solution.getFitness();
											double solutionDi = fitness[0];//Math.sqrt(fitness[0]*fitness[0]+fitness[1]*fitness[1]);
											
											if(solutionDi < bestDi){
												bestSol = solution;
												bestDi = solutionDi;
												
												System.out.println("Best NF = " + bestDi);
												System.out.println(bestSol);
												System.out.println(bestSol.printAmps());
											}

											/*
											 * The maximum output power in the link. It is
											 * related with the nonlinear imparments double
											 * maxPower = amplifiers[0].getOutputPower();
											 * for(int p=1; p<amplifiers.length; p++){
											 * if(amplifiers[p].getOutputPower() > maxPower)
											 * maxPower = amplifiers[p].getOutputPower(); }
											 * solution.setFitness(3, maxPower); //max(Pi)
											 */
										}

										if (solution != null) {
											this.addSolutionEA(solution);
										}

										p -= STEP;
										contador++;
										
										
									}
									o -= STEP;
								}
								n -= STEP;
							}
							m -= STEP;
						}
						l -= STEP;
					}

					k -= STEP;
				}

				j -= STEP;
			}
			
			long te = System.currentTimeMillis();
			System.out.println("End = " + (te -ti) + " msec.\n\n");
			try
			{
				printExternalArchive();
			}
			catch(Exception e)
			{

			}

			i-= STEP;
			// System.out.print(((contador/totalComb)*100) + "% \t");
		}
	}

	private void printExternalArchive() throws FileNotFoundException {
		PrintWriter pareto = new PrintWriter(arquivo + "pareto_restr.txt");
		//PrintWriter amps = new PrintWriter(arquivo + "amplificadores_restr.txt");

		for(SolutionBFMethod s : externalArchive){
			pareto.print(s + "\n");
			//amps.print(s.printAmps() + "\n");
		}

		pareto.close();
		//amps.close();
	}

	private void addSolutionEA(SolutionBFMethod solution) {

		if(externalArchive == null){
			externalArchive = new ArrayList<SolutionBFMethod>();	
		}
		/*else
		{
			for(SolutionBFMethod s : externalArchive){
				if(compareSolutionByDominace(s, solution) == Dominance.DOMINATES){
					return;
				}
			}

			ArrayList<SolutionBFMethod> temp = new ArrayList<SolutionBFMethod>();
			for(SolutionBFMethod s : externalArchive){
				if(compareSolutionByDominace(solution, s) != Dominance.DOMINATES){
					temp.add(s);
				}
			}			

			externalArchive = temp;
		}*/

		externalArchive.add(solution);

	}

	protected Dominance compareSolutionByDominace(SolutionBFMethod solution, SolutionBFMethod anotherSolution){
		int numObj = NUMBER_OBJ;
		boolean lostInAllDimensions = true;
		boolean winInAllDimensions = true;
		double[] fitness =  solution.getFitness();
		double[] anotherFitness =  anotherSolution.getFitness();

		for(int currentObj=0; currentObj < numObj ; currentObj++){

			if(fitness[currentObj] > anotherFitness[currentObj]){
				winInAllDimensions = false;
			}

			if(fitness[currentObj] < anotherFitness[currentObj]){
				lostInAllDimensions = false;
			}

			if(!winInAllDimensions && !lostInAllDimensions){
				return Dominance.INCOMPARABLE;
			}
		}

		if(winInAllDimensions && lostInAllDimensions){
			return Dominance.INCOMPARABLE;
		}

		if(winInAllDimensions){
			return Dominance.DOMINATES;
		}

		if(lostInAllDimensions){
			return Dominance.DOMINATED;
		}

		return Dominance.INCOMPARABLE;

	}

	public static void main(String[] args){
		STEP = 1.0f;//Float.parseFloat(args[0]);
		// System.out.println("Step " + STEP);

		int runs = 1;

		for (int i = 0; i < runs; i++) {
			long ti = System.currentTimeMillis();

			BruteForceMethodRestricted_8Amp bf = new BruteForceMethodRestricted_8Amp();

			bf.run();

			System.out.println(System.currentTimeMillis() - ti);
		}
	}


}
