package br.upe.heuristics.bruteForce;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.PrintWriter;
import java.util.ArrayList;

import com.sun.jmx.snmp.Timestamp;

import br.upe.base.Amplifier;
import br.upe.base.AmplifierType;
import br.upe.base.AmplifierVOA;
import br.upe.base.ObjectiveFunction;
import br.upe.base.OpticalChannel;
import br.upe.base.OpticalSignal;
import br.upe.initializations.BruteForceInitialization;
import br.upe.mascara.PowerMask;
import br.upe.mascara.PowerMaskFactory;
import br.upe.metrics.GNLIMetric;
import br.upe.objfunctions.linerInterpolation.LinearInterpolationFunction;
import br.upe.objfunctions.rn.util.NormalizationUtility;
import br.upe.objfunctions.rn.util.NormalizationUtilityFactory;
import br.upe.signal.factory.PowerMaskSignal;
import br.upe.simulations.simsetups.SimSetAMPVOA;
import br.upe.simulations.simsetups.SimulationSetup;
import br.upe.util.DecibelConverter;
import br.upe.util.Dominance;

public class BFMethod_4amps {

    private float INPUT_POWER = 0; // dBm
    private static final int NUMBER_OBJ = 2;
    private static float STEP = 1f; // dB
    private static float MAX_OUT_POWER = 0.0f; // dBm

    private BruteForceInitialization initialization;
    private ObjectiveFunction function;
    private File arquivo;
    private SimulationSetup simSet;
    private OpticalSignal inputSignal;
    private AmplifierType ampType;
    private float inputPower;

    private ArrayList<SolutionBFMethod> externalArchive;

    public BFMethod_4amps() {
	ampType = AmplifierType.EDFA_2_2_STG;

	NormalizationUtility nu = NormalizationUtilityFactory.getInstance().fabricate(ampType);
	function = new LinearInterpolationFunction();

	int numberCh = 40;
	inputPower = -21f;
	simSet = new SimSetAMPVOA(numberCh, inputPower, 9.0f);

	PowerMaskSignal signal = new PowerMaskSignal(numberCh, ampType, simSet.getCHANNEL_POWER(), 30);
	inputSignal = signal.createSignal();

	// Definindo ganho máximo
	MAX_OUT_POWER = simSet.getMaxOutputPower();
	System.out.println(MAX_OUT_POWER);

	boolean considerVOA = true;
	initialization = new BruteForceInitialization(ampType, considerVOA, MAX_OUT_POWER);

	INPUT_POWER = inputSignal.getTotalPower();

	try {
	    arquivo = new File("LI_edfastg22_ase_" + STEP);
	} catch (Exception e) {

	}

    }

    public void run() {
	GNLIMetric gnliMetric = new GNLIMetric(28e9, 100e9, 39, inputPower, 100e3);

	PowerMask pm = PowerMaskFactory.getInstance().fabricatePowerMask(ampType);

	double totalCombAmp = pm.getMaxGain() - pm.getMinGain() + 1;
	double totalCombVoa = simSet.getVOA_MAX_ATT();

	totalCombAmp = totalCombAmp * totalCombAmp * totalCombAmp * totalCombAmp;
	totalCombVoa = totalCombVoa * totalCombVoa * totalCombVoa * totalCombVoa;

	double totalComb = totalCombAmp * totalCombVoa;

	double contador = 0;

	float shift = 0.0f;

	File arquivoT = new File("edfa22_4amps_time.txt");
	Timestamp timeIni = new Timestamp();

	while (shift < STEP) {
	    float i = pm.getMaxGain() - shift;
	    while (i >= pm.getMinGain()) { // G1

		float j = simSet.getVOA_MAX_ATT() - shift;
		while (j >= 0) { // VOA1

		    float k = pm.getMaxGain() - shift;
		    while (k >= pm.getMinGain()) { // G2

			float l = simSet.getVOA_MAX_ATT() - shift;
			while (l >= 0) { // VOA2

			    float m = pm.getMaxGain() - shift;
			    while (m >= pm.getMinGain()) { // G3

				float n = simSet.getVOA_MAX_ATT() - shift;
				while (n >= 0) { // VOA3

				    float o = pm.getMaxGain() - shift;
				    while (o >= pm.getMinGain()) { // G4

					float p = simSet.getVOA_MAX_ATT() - shift;
					while (p >= 0) { // VOA4

					    float[] gains = { i, k, m, o };
					    float[] attenuations = { j, l, n, p };

					    initialization.setGains(gains);
					    initialization.setAttenuations(attenuations);
					    OpticalSignal signalTemp = inputSignal.clone();
					    Amplifier[] amplifiers = initialization.initialize(
						    simSet.getNumberOfAmplifiers(), INPUT_POWER, 0,
						    simSet.getLINK_LOSSES(), function, signalTemp);

					    // Solucao fora das restricoes
					    if (amplifiers == null
						    || Math.abs(amplifiers[0].getInputPower()) > (Math.abs(INPUT_POWER)
							    + 0.5)
						    || Math.abs(amplifiers[0].getInputPower()) < (Math.abs(INPUT_POWER)
							    - 0.5)
						    || !this.isOutputPowerCorrect(amplifiers)) { // restriction
						// to
						// guarantee
						// the
						// maximum
						// output
						// power
						p -= STEP;
						contador++;
						continue;
					    }

					    SolutionBFMethod solution = null;

					    float ampVoaAtt = ((AmplifierVOA) amplifiers[amplifiers.length - 1])
						    .getVoaOutAttenuation();
					    float voaAttenuation = (float) (amplifiers[amplifiers.length - 1]
						    .getOutputPower() - ampVoaAtt - INPUT_POWER
						    - simSet.getROADM_ATT());
					    ((AmplifierVOA) amplifiers[amplifiers.length - 1])
						    .increaseVoaOutAttenuation(voaAttenuation);

					    // If the output power of the link
					    // is less than the
					    // input power, then the solution
					    // isn't desirable.
					    // And, if the output power is
					    // greater than the
					    // input
					    // power + voa max attenuation +
					    // roadm attenuation,
					    // then
					    // the solution is not desirable
					    if (amplifiers[amplifiers.length - 1].getOutputPower() >= INPUT_POWER
						    && ((AmplifierVOA) amplifiers[amplifiers.length - 1])
							    .getOutputPowerAfterVOA() <= (INPUT_POWER
								    + simSet.getVOA_MAX_ATT() + simSet.getROADM_ATT())
						    && voaAttenuation >= 0) {

						solution = new SolutionBFMethod(NUMBER_OBJ);

						solution.setAmplifiers(amplifiers);

						// solution.setFitness(0,
						// nfMetric.evaluate(amplifiers));
						// // nf
						solution.setFitness(0, calculateTilt(signalTemp)); // gf

						gnliMetric.evaluate(amplifiers);
						solution.setFitness(1, gnliMetric.worstOSNR_ASE()); // OSNR

						// Choose best solution
						/*
						 * double[] fitness =
						 * solution.getFitness(); double
						 * solutionDi =
						 * Math.sqrt(fitness[2] *
						 * fitness[2] / fitness[1] *
						 * fitness[1]);
						 * 
						 * if (solutionDi > bestDi) {
						 * bestSol = solution; bestDi =
						 * solutionDi; }
						 */
					    }

					    if (solution != null) {

						if (solution.getFitness()[1] > 28)
						    System.out.println();

						this.addSolutionEA(solution);
					    }

					    p -= STEP;
					    contador++;
					}

					o -= STEP;
				    }
				    n -= STEP;
				}

				m -= STEP;
			    }
			    l -= STEP;
			}
			k -= STEP;
		    }

		    j -= STEP;

		    double perc = (contador / totalComb) * 100;
		    System.out.println(perc);

		    /*
		     * long te = System.currentTimeMillis(); System.out.println(
		     * "End = " + (te -ti) + " msec.\n\n");
		     */

		}

		try {
		    printExternalArchive(i);
		    Timestamp timeEnd = new Timestamp();
		    PrintWriter time = new PrintWriter(arquivoT);
		    time.println("Start = " + timeIni.getDate());
		    time.println("End = " + timeEnd.getDate());
		    time.close();
		} catch (Exception e) {

		}

		i -= STEP;
	    }
	    shift += 1;
	}

	Timestamp timeEnd = new Timestamp();
	System.out.println("Start = " + timeIni.getDate());
	System.out.println("End = " + timeEnd.getDate());
    }

    private void printExternalArchive(float k) throws FileNotFoundException {

	if (externalArchive.size() == 0)
	    return;

	PrintWriter pareto = new PrintWriter(arquivo + "" + k + "_par.txt");
	PrintWriter amps = new PrintWriter(arquivo + "" + k + "_amp.txt");

	for (SolutionBFMethod s : externalArchive) {
	    pareto.print(s + "\n");
	    amps.print(s.printAmps() + "\n");
	}

	pareto.close();
	amps.close();
    }

    private boolean isOutputPowerCorrect(Amplifier[] amplifiers) {
	for (int i = 0; i < amplifiers.length; i++) {
	    if (amplifiers[i] instanceof AmplifierVOA)
		continue;

	    if (amplifiers[i].getOutputPower() > MAX_OUT_POWER + 0.5f) {
		return false;
	    }
	}

	return true;
    }

    private void addSolutionEA(SolutionBFMethod solution) {

	if (externalArchive == null) {
	    externalArchive = new ArrayList<SolutionBFMethod>();
	} else {
	    for (SolutionBFMethod s : externalArchive) {
		if (compareSolutionByDominace(s, solution) == Dominance.DOMINATES) {
		    return;
		}
	    }

	    for (int i = 0; i < externalArchive.size(); i++) {
		SolutionBFMethod s = externalArchive.get(i);
		if (compareSolutionByDominace(solution, s) == Dominance.DOMINATES) {
		    externalArchive.remove(i);
		    i--;
		}
	    }
	}

	// for (SolutionBFMethod s : externalArchive)
	// { if (isEqual(s,solution)) return; }


	externalArchive.add(solution);
    }

    private boolean isEqual(SolutionBFMethod s1, SolutionBFMethod s2) {
	for (int i = 0; i < s1.getNumberOfObjectives(); i++) {
	    if (s1.getFitness()[i] != s2.getFitness()[i])
		return false;
	}
	return true;
    }

    protected Dominance compareSolutionByDominace(SolutionBFMethod solution, SolutionBFMethod anotherSolution) {
	int numObj = NUMBER_OBJ;
	boolean lostInAllDimensions = true;
	boolean winInAllDimensions = true;
	double[] fitness = solution.getFitness();
	double[] anotherFitness = anotherSolution.getFitness();

	for (int currentObj = 0; currentObj < numObj; currentObj++) {

	    if (currentObj == 1) {
		fitness[currentObj] *= -1;
		anotherFitness[currentObj] *= -1;
	    }

	    if (fitness[currentObj] > anotherFitness[currentObj]) {
		winInAllDimensions = false;
	    }

	    if (fitness[currentObj] < anotherFitness[currentObj]) {
		lostInAllDimensions = false;
	    }

	    if (currentObj == 1) {
		fitness[currentObj] *= -1;
		anotherFitness[currentObj] *= -1;
	    }

	    if (!winInAllDimensions && !lostInAllDimensions) {
		return Dominance.INCOMPARABLE;
	    }
	}

	if (winInAllDimensions && lostInAllDimensions) {
	    return Dominance.INCOMPARABLE;
	}

	if (winInAllDimensions) {
	    return Dominance.DOMINATES;
	}

	if (lostInAllDimensions) {
	    return Dominance.DOMINATED;
	}

	return Dominance.INCOMPARABLE;

    }

    public double calculateOSNR(OpticalSignal signal) {
	double minOSNR = Double.MAX_VALUE;
	for (OpticalChannel c : signal.getChannels()) {
	    double signalLin = DecibelConverter.toLinearScale(c.getSignalPower());
	    double noiseLin = DecibelConverter.toLinearScale(c.getNoisePower());
	    double OSNR = signalLin / noiseLin;

	    if (OSNR < minOSNR) {
		minOSNR = OSNR;
	    }
	}

	return DecibelConverter.toDecibelScale(minOSNR);
    }

    public double calculateTilt(OpticalSignal signal) {
	double maxPeak = Double.MIN_VALUE;
	double minPeak = Double.MAX_VALUE;

	for (OpticalChannel c : signal.getChannels()) {
	    double signalLin = DecibelConverter.toLinearScale(c.getSignalPower());

	    if (signalLin > maxPeak) {
		maxPeak = signalLin;
	    }
	    if (signalLin < minPeak) {
		minPeak = signalLin;
	    }
	}

	return DecibelConverter.toDecibelScale(maxPeak / minPeak);
    }

    public static void main(String[] args) {
	int runs = 1;
	STEP = Float.parseFloat(args[0]);

	System.out.println("STEP = " + STEP);

	for (int i = 0; i < runs; i++) {

	    BFMethod_4amps bf = new BFMethod_4amps();

	    bf.run();
	}
    }


}
