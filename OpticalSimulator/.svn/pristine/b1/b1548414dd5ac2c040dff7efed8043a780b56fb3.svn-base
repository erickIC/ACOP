package br.upe.initializations;

import br.upe.base.Amplifier;
import br.upe.base.AmplifierType;
import br.upe.base.ObjectiveFunction;
import br.upe.util.MaxMinUtility;

public class UniformInitializationMaxPower implements InitializationStrategy {

	private float[] gains;
	private AmplifierType type;
	private float maxOutPower;

	public UniformInitializationMaxPower(AmplifierType type, float maxOutPower){
		this.type = type;
		this.maxOutPower = maxOutPower;
	}

	@Override	
	public Amplifier[] initialize(int numberOfAmplifiers, float linkInputPower,
			float linkOutputPower, float[] linkLosses, ObjectiveFunction function) {
		Amplifier[] amplifiers = new Amplifier[numberOfAmplifiers];

		if(gains != null){
			for(int i=0; i<numberOfAmplifiers; i++){
				//The first amplifier 
				if(i==0){
					amplifiers[0] = new Amplifier(linkInputPower, gains[i], type);
				}
				//The others amplifiers
				else {
					float inputPower = amplifiers[i-1].getOutputPower() - linkLosses[i-1];
					amplifiers[i] = new Amplifier(inputPower, gains[i], type);
				}

				if(applyRestriction(amplifiers[i])){
					function.defineNewOperationPoint(amplifiers[i]);
				}
				else{
					return null;
				}
			}
		}
		else{
			MaxMinUtility maxMin = new MaxMinUtility(type);
			for(int i=0; i<numberOfAmplifiers; i++){
				//The first amplifier 
				if(i==0){
					amplifiers[0] = new Amplifier(linkInputPower,type);
					amplifiers[0].setOutputPower(linkOutputPower + maxMin.getMinGain()) ;
					amplifiers[0].calculateGain();
				}
				//The others amplifiers
				else {
					float inputPower = amplifiers[i-1].getOutputPower() - linkLosses[i-1];
					amplifiers[i] = new Amplifier(inputPower, type);
					amplifiers[i].setOutputPower(this.maxOutPower);
					amplifiers[i].calculateGain();
				}
			}
		}

		return amplifiers;
	}

	/**
	 * @return the gains
	 */
	public float[] getGains() {
		return gains;
	}

	/**
	 * @param gains the gains to set
	 */
	public void setGains(float[] gains) {
		this.gains = gains;
	}

	private boolean applyRestriction(Amplifier amplifier) {
		amplifier.calculateGain();
		MaxMinUtility maxMinRes = new MaxMinUtility(amplifier.getType());

		if(amplifier.getGain() < maxMinRes.getMinGain()){
			return false;
		}
		else if(amplifier.getGain() > maxMinRes.getMaxGain()){
			return false;
		}
		//Restricao para manter pontos dentro da mascara.
		else{
			int gain = (int)amplifier.getGain();
			float relax = 0.2f;

			//Se o Pin é maior do que o maximo ou menor que o mínimo.
			if(amplifier.getInputPower() > (maxMinRes.getMaxInput(gain) + relax)
					|| amplifier.getInputPower() < (maxMinRes.getMinInput(gain)-relax)){
				return false;
			}

		}

		return true;
	}

}
