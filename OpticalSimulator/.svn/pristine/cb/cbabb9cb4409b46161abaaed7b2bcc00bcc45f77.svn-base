package br.upe.heuristics.bruteForce;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.PrintWriter;
import java.util.ArrayList;

import com.sun.jmx.snmp.Timestamp;

import br.upe.base.Amplifier;
import br.upe.base.AmplifierType;
import br.upe.base.AmplifierVOA;
import br.upe.base.ObjectiveFunction;
import br.upe.base.OpticalChannel;
import br.upe.base.OpticalSignal;
import br.upe.initializations.BruteForceInitialization;
import br.upe.mascara.PowerMask;
import br.upe.mascara.PowerMaskFactory;
import br.upe.metrics.GNLIMetric;
import br.upe.objfunctions.rn.NNFunction;
import br.upe.objfunctions.rn.util.NormalizationUtility;
import br.upe.objfunctions.rn.util.NormalizationUtilityFactory;
import br.upe.signal.factory.PowerMaskSignal;
import br.upe.simulations.simsetups.SimSetAMPVOA_2Amps;
import br.upe.simulations.simsetups.SimulationSetup;
import br.upe.util.DecibelConverter;
import br.upe.util.Dominance;

public class BFMethod_2amps {

    private float INPUT_POWER = 0; // dBm
    private static final int NUMBER_OBJ = 2;
    private static final float STEP = 0.5f; // dB
    private static float MAX_OUT_POWER = 0.0f; // dBm

    private BruteForceInitialization initialization;
    private ObjectiveFunction function;
    private File arquivo;
    private SimulationSetup simSet;
    private OpticalSignal inputSignal;
    private AmplifierType ampType;
    private float inputPower;

    private ArrayList<SolutionBFMethod> externalArchive;

    public BFMethod_2amps() {
	ampType = AmplifierType.EDFA_1_STG;

	NormalizationUtility nu = NormalizationUtilityFactory.getInstance().fabricate(ampType);
	function = new NNFunction(nu); // LinearInterpolationFunction();

	int numberCh = 39;
	inputPower = -21f;
	simSet = new SimSetAMPVOA_2Amps(numberCh, inputPower, 9.0f);

	PowerMaskSignal signal = new PowerMaskSignal(numberCh, ampType, simSet.getCHANNEL_POWER(), 30);
	inputSignal = signal.createSignal();

	// Definindo ganho máximo
	MAX_OUT_POWER = simSet.getMaxOutputPower();
	// System.out.println(MAX_OUT_POWER);

	boolean considerVOA = true;
	initialization = new BruteForceInitialization(ampType, considerVOA, MAX_OUT_POWER);

	INPUT_POWER = inputSignal.getTotalPower();

	try {
	    arquivo = new File("edfa1_2amps/e1_2amps_");
	} catch (Exception e) {

	}

    }

    public void run() {

	// long ti = System.currentTimeMillis();
	// System.out.println("Start");
	GNLIMetric gnliMetric = new GNLIMetric(28e9, 100e9, 39, inputPower, 100e3);

	PowerMask pm = PowerMaskFactory.getInstance().fabricatePowerMask(ampType);

	double totalCombAmp = pm.getMaxGain() - pm.getMinGain() + 1;
	double totalCombVoa = simSet.getVOA_MAX_ATT();

	totalCombAmp = totalCombAmp * totalCombAmp * 100;
	totalCombVoa = totalCombVoa * totalCombVoa * 100;

	double totalComb = totalCombAmp * totalCombVoa;

	double contador = 0;

	float shift = 0.0f;

	Timestamp timeIni = new Timestamp();

	while (shift < STEP) {
	    float i = pm.getMaxGain() - shift;
	    while (i >= pm.getMinGain()) { // G1

		float j = simSet.getVOA_MAX_ATT() - shift - 10;
		while (j >= 0) { // VOA1

		    float k = pm.getMaxGain() - shift;
		    while (k >= pm.getMinGain()) { // G2

			float l = simSet.getVOA_MAX_ATT() - shift - 10;
			while (l >= 0) { // VOA2

			    if (i == 22.4 && j == 4.8 && k == 28.1 && l == 0.4)
				System.out.println();
			    
			    float[] gains = { i, k };
			    float[] attenuations = { j, l };

			    initialization.setGains(gains);
			    initialization.setAttenuations(attenuations);
			    OpticalSignal signalTemp = inputSignal.clone();
			    Amplifier[] amplifiers = initialization.initialize(simSet.getNumberOfAmplifiers(),
				    INPUT_POWER, 0, simSet.getLINK_LOSSES(), function, signalTemp);

			    // Solucao fora das restricoes
			    if (amplifiers == null
				    || Math.abs(amplifiers[0].getInputPower()) > (Math.abs(INPUT_POWER) + 0.5)
				    || Math.abs(amplifiers[0].getInputPower()) < (Math.abs(INPUT_POWER) - 0.5)
				    || !this.isOutputPowerCorrect(amplifiers)) { // restriction
				// to
				// guarantee
				// the
				// maximum
				// output
				// power
				l -= STEP;
				contador++;
				continue;
			    }

			    SolutionBFMethod solution = null;

			    float ampVoaAtt = ((AmplifierVOA) amplifiers[amplifiers.length - 1]).getVoaOutAttenuation();
			    float voaAttenuation = (float) (amplifiers[amplifiers.length - 1].getOutputPower()
				    - ampVoaAtt - INPUT_POWER - simSet.getROADM_ATT());
			    ((AmplifierVOA) amplifiers[amplifiers.length - 1])
			    .increaseVoaOutAttenuation(voaAttenuation);

			    // If the output power of the link is less than the
			    // input power, then the solution isn't desirable.
			    // And, if the output power is greater than the
			    // input
			    // power + voa max attenuation + roadm attenuation,
			    // then
			    // the solution is not desirable
			    if (amplifiers[amplifiers.length - 1].getOutputPower() >= INPUT_POWER
				    && ((AmplifierVOA) amplifiers[amplifiers.length - 1])
				    .getOutputPowerAfterVOA() <= (INPUT_POWER + simSet.getVOA_MAX_ATT()
				    + simSet.getROADM_ATT())
				    && voaAttenuation >= 0) {

				solution = new SolutionBFMethod(NUMBER_OBJ);

				solution.setAmplifiers(amplifiers);

				// solution.setFitness(0,
				// nfMetric.evaluate(amplifiers)); // nf
				solution.setFitness(0, calculateTilt(signalTemp)); // gf

				gnliMetric.evaluate(amplifiers);
				solution.setFitness(1, gnliMetric.worstOSNR_NLI()); // OSNR

				// Choose best solution
				/*
				 * double[] fitness = solution.getFitness();
				 * double solutionDi = Math.sqrt(fitness[2] *
				 * fitness[2] / fitness[1] * fitness[1]);
				 * 
				 * if (solutionDi > bestDi) { bestSol =
				 * solution; bestDi = solutionDi; }
				 */
			    }

			    if (solution != null) {
				this.addSolutionEA(solution);
			    }

			    l -= STEP;
			    contador++;
			}

			k -= STEP;
		    }

		    j -= STEP;

		    double perc = (contador / totalComb) * 100;
		    // System.out.printf("%3.2f \n", perc);

		    /*
		     * long te = System.currentTimeMillis(); System.out.println(
		     * "End = " + (te -ti) + " msec.\n\n");
		     */

		}
		i -= STEP;
	    }
	    shift += 1;
	}

	try {
	    printExternalArchive(0);
	} catch (Exception e) {

	}

	Timestamp timeEnd = new Timestamp();

	System.out.println("Start = " + timeIni.getDate());
	System.out.println("End = " + timeEnd.getDate());

	// System.out.println("Best NF = " + bestDi);
	// System.out.println(bestSol);
	// System.out.println(bestSol.printAmps());
    }

    private void printExternalArchive(float k) throws FileNotFoundException {

	if (externalArchive.size() == 0)
	    return;

	PrintWriter pareto = new PrintWriter(arquivo + "" + k + "_par.txt");
	PrintWriter amps = new PrintWriter(arquivo + "" + k + "_amp.txt");

	for (SolutionBFMethod s : externalArchive) {
	    pareto.print(s + "\n");
	    amps.print(s.printAmps() + "\n");
	    // System.out.println(s);
	}

	externalArchive.clear();
	pareto.close();
	amps.close();
    }

    private boolean isOutputPowerCorrect(Amplifier[] amplifiers) {
	for (int i = 0; i < amplifiers.length; i++) {
	    if (amplifiers[i] instanceof AmplifierVOA)
		continue;

	    if (amplifiers[i].getOutputPower() > MAX_OUT_POWER + 0.5f) {
		return false;
	    }
	}

	return true;
    }

    private void addSolutionEA(SolutionBFMethod solution) {

	if (externalArchive == null) {
	    externalArchive = new ArrayList<SolutionBFMethod>();
	} else {
	    for (SolutionBFMethod s : externalArchive) {
		if (compareSolutionByDominace(s, solution) == Dominance.DOMINATES) {
		    return;
		}
	    }

	    for (int i = 0; i < externalArchive.size(); i++) {
		SolutionBFMethod s = externalArchive.get(i);
		if (compareSolutionByDominace(solution, s) == Dominance.DOMINATES) {
		    externalArchive.remove(i);
		    i--;
		}
	    }
	}

	// for (SolutionBFMethod s : externalArchive)
	// { if (isEqual(s,solution)) return; }


	externalArchive.add(solution);
    }

    private boolean isEqual(SolutionBFMethod s1, SolutionBFMethod s2) {
	for (int i = 0; i < s1.getNumberOfObjectives(); i++) {
	    if (s1.getFitness()[i] != s2.getFitness()[i])
		return false;
	}
	return true;
    }

    protected Dominance compareSolutionByDominace(SolutionBFMethod solution, SolutionBFMethod anotherSolution) {
	int numObj = NUMBER_OBJ;
	boolean lostInAllDimensions = true;
	boolean winInAllDimensions = true;
	double[] fitness = solution.getFitness();
	double[] anotherFitness = anotherSolution.getFitness();

	for (int currentObj = 0; currentObj < numObj; currentObj++) {

	    if (currentObj == 1) {
		fitness[currentObj] *= -1;
		anotherFitness[currentObj] *= -1;
	    }

	    if (fitness[currentObj] > anotherFitness[currentObj]) {
		winInAllDimensions = false;
	    }

	    if (fitness[currentObj] < anotherFitness[currentObj]) {
		lostInAllDimensions = false;
	    }

	    if (currentObj == 1) {
		fitness[currentObj] *= -1;
		anotherFitness[currentObj] *= -1;
	    }

	    if (!winInAllDimensions && !lostInAllDimensions) {
		return Dominance.INCOMPARABLE;
	    }
	}

	if (winInAllDimensions && lostInAllDimensions) {
	    return Dominance.INCOMPARABLE;
	}

	if (winInAllDimensions) {
	    return Dominance.DOMINATES;
	}

	if (lostInAllDimensions) {
	    return Dominance.DOMINATED;
	}

	return Dominance.INCOMPARABLE;

    }

    public double calculateOSNR(OpticalSignal signal) {
	double minOSNR = Double.MAX_VALUE;
	for (OpticalChannel c : signal.getChannels()) {
	    double signalLin = DecibelConverter.toLinearScale(c.getSignalPower());
	    double noiseLin = DecibelConverter.toLinearScale(c.getNoisePower());
	    double OSNR = signalLin / noiseLin;

	    if (OSNR < minOSNR) {
		minOSNR = OSNR;
	    }
	}

	return DecibelConverter.toDecibelScale(minOSNR);
    }

    public double calculateTilt(OpticalSignal signal) {
	double maxPeak = Double.MIN_VALUE;
	double minPeak = Double.MAX_VALUE;

	for (OpticalChannel c : signal.getChannels()) {
	    double signalLin = DecibelConverter.toLinearScale(c.getSignalPower());

	    if (signalLin > maxPeak) {
		maxPeak = signalLin;
	    }
	    if (signalLin < minPeak) {
		minPeak = signalLin;
	    }
	}

	return DecibelConverter.toDecibelScale(maxPeak / minPeak);
    }

    public static void main(String[] args) {
	int runs = 1;

	for (int i = 0; i < runs; i++) {
	    long ti = System.currentTimeMillis();

	    BFMethod_2amps bf = new BFMethod_2amps();

	    bf.run();

	    System.out.println(System.currentTimeMillis() - ti);
	}
    }


}
