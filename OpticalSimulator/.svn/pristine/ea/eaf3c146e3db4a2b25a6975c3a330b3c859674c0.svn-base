package br.upe.initializations;

import br.upe.base.Amplifier;
import br.upe.base.AmplifierType;
import br.upe.base.AmplifierVOA;
import br.upe.base.ObjectiveFunction;
import br.upe.util.MaxMinUtility;

public class UniformInitializationAMPVOA implements InitializationStrategy {

	private float[] gains;
	private float[] voas;
	private AmplifierType type;

	public UniformInitializationAMPVOA(AmplifierType type){
		this.type = type;
	}

	@Override	
	public Amplifier[] initialize(int numberOfAmplifiers, float linkInputPower,
			float linkOutputPower, float[] linkLosses, ObjectiveFunction function) {
		AmplifierVOA[] amplifiers = new AmplifierVOA[numberOfAmplifiers];

		if(gains != null){
			for(int i=0; i<numberOfAmplifiers; i++){
				//The first amplifier 
				if(i==0){
					amplifiers[0] = new AmplifierVOA(linkInputPower, gains[i], type);
				}
				//The others amplifiers
				else {
					float inputPower = amplifiers[i-1].getOutputPowerAfterVOA() - linkLosses[i-1];
					amplifiers[i] = new AmplifierVOA(inputPower, gains[i], type);
				}

				//The voa attenuation is defined 
				if(voas!= null){
					amplifiers[i].setVoaInAttenuation(voas[i*2]);
					amplifiers[i].setVoaOutAttenuation(voas[(i*2)+1]);
				}

				if(applyRestriction(amplifiers[i])){
					function.defineNewOperationPoint(amplifiers[i]);
				}
				else{
					return null;
				}
			}
		}
		else{
			MaxMinUtility maxMin = new MaxMinUtility(type);

			for(int i=0; i<numberOfAmplifiers; i++){
				//The first amplifier 
				if(i==0){
					amplifiers[0] = new AmplifierVOA(linkInputPower,type);
					amplifiers[0].setOutputPower(linkOutputPower + maxMin.getMinGain()) ;
					amplifiers[0].calculateGain();
				}
				//The others amplifiers
				else {
					float inputPower = amplifiers[i-1].getOutputPower() - linkLosses[i-1];
					amplifiers[i] = new AmplifierVOA(inputPower, type);
				}
			}
		}

		return amplifiers;
	}

	/**
	 * @return the gains
	 */
	public float[] getGains() {
		return gains;
	}

	/**
	 * @param gains the gains to set
	 */
	public void setGains(float[] gains) {
		this.gains = gains;
	}
	
	public void setVoas(float[] voas){
		this.voas = voas;
	}

	private boolean applyRestriction(Amplifier amplifier) {
		amplifier.calculateGain();

		MaxMinUtility maxMinRes = new MaxMinUtility(amplifier.getType());
		
		if(amplifier.getGain() < maxMinRes.getMinGain()){
			return false;
		}
		else if(amplifier.getGain() > maxMinRes.getMaxGain()){
			return false;
		}
		//Restricao para manter pontos dentro da mascara.
		else{
			int gain = (int)amplifier.getGain();
			float relax = 0.2f;

			//Se o Pin é maior do que o maximo ou menor que o mínimo.
			if(amplifier.getInputPower() > (maxMinRes.getMaxInput(gain) + relax)
					|| amplifier.getInputPower() < (maxMinRes.getMinInput(gain)-relax)){
				return false;
			}

		}

		return true;
	}

}
